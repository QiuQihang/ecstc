<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_09) on Sun Jan 28 17:29:31 PST 2007 -->
<TITLE>
samples.preview_new_graphdraw (JUNG 1.7.6 API)
</TITLE>

<META NAME="keywords" CONTENT="samples.preview_new_graphdraw package">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="samples.preview_new_graphdraw (JUNG 1.7.6 API)";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../samples/graph/southern/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../samples/preview_new_graphdraw/event/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
Package samples.preview_new_graphdraw
</H2>
This module provides a new way of thinking about graph drawing. 

<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Interface Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../samples/preview_new_graphdraw/EdgeRenderer.html" title="interface in samples.preview_new_graphdraw">EdgeRenderer</A></B></TD>
<TD>An EdgeRenderer is responsible for rendering every VisEdge that comes its
 way</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../samples/preview_new_graphdraw/LayoutEmitter.html" title="interface in samples.preview_new_graphdraw">LayoutEmitter</A></B></TD>
<TD>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../samples/preview_new_graphdraw/VertexRenderer.html" title="interface in samples.preview_new_graphdraw">VertexRenderer</A></B></TD>
<TD>&nbsp;</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Class Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../samples/preview_new_graphdraw/AbstractLayout.html" title="class in samples.preview_new_graphdraw">AbstractLayout</A></B></TD>
<TD>This class is essentially a decorator: for each vertex or edge, it must return a
 VisVertex or VisEdge object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../samples/preview_new_graphdraw/Coordinates.html" title="class in samples.preview_new_graphdraw">Coordinates</A></B></TD>
<TD>Stores coordinates (X,Y) for vertices being visualized.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../samples/preview_new_graphdraw/CoordinateUtil.html" title="class in samples.preview_new_graphdraw">CoordinateUtil</A></B></TD>
<TD>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../samples/preview_new_graphdraw/CoordinateUtil.Line.html" title="class in samples.preview_new_graphdraw">CoordinateUtil.Line</A></B></TD>
<TD>A class which represents a geometric line.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../samples/preview_new_graphdraw/EmittedLayout.html" title="class in samples.preview_new_graphdraw">EmittedLayout</A></B></TD>
<TD>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../samples/preview_new_graphdraw/OldToNewRenderer.html" title="class in samples.preview_new_graphdraw">OldToNewRenderer</A></B></TD>
<TD>This utility class converts your favorite old-style renderer into the 
 newfangled NewGraphDraw VertexRenderer and EdgeRenderer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../samples/preview_new_graphdraw/StaticLayout.html" title="class in samples.preview_new_graphdraw">StaticLayout</A></B></TD>
<TD>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../samples/preview_new_graphdraw/VisEdge.html" title="class in samples.preview_new_graphdraw">VisEdge</A></B></TD>
<TD>This implements an edge between two points. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../samples/preview_new_graphdraw/VisVertex.html" title="class in samples.preview_new_graphdraw">VisVertex</A></B></TD>
<TD>&nbsp;</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
Package samples.preview_new_graphdraw Description
</H2>

<P>
<p>This module provides a new way of thinking about graph drawing. 
In particular, it is designed to be a great deal more flexible than 
the previous model, and to allow users to manage a great deal more than
they once had.</p>

<p>At its core is a notion of the EmittedLayout. An EmittedLayout is
a way of storing the current positions of a set of vertices. An EmittedLayout
comes from one of two places. First, it may be generated anew from a
StaticLayout. A static layout generates a layout de novo (well, from outside the graphics 
system): from a saved file, algorithmically, or whatever. The call "emit" to a 
static layout must produce a new EmittedLayout. (This need not work more than once).</p>

<p>Second, it may come from an animation cycle. Largely, these consist of IterableLayouts. 
An IterableLayout takes in a starting vertex configuration (in the form of an
EmittedLayout), and is responsible for producing a new vertex configuration. 
When advance() is called on an iterable layout, it (presumably) moves forward
one step in time. When emit() is called, the last stable copy of the data is retruned.</p>

<p>Note that this has several implications:
First, the sequence advance() ; emit()  ; 	emit() ; 	emit()
should return the t=1 version of the thing three times in a row.</p>

<p>Second, this should be fairly thread-safe. Specifically, it should be safe to call 
emit() while advance() is still running. (Throughout, I assume that Advance may
take a rather long time to run, and that the application should be interactive
even while advance is waiting. When advance is fairly fast, some gratuitous
copies of the layout may be made.)</p>

<p>The mechanism responsible for handling this iteration is the LayoutIterator. It repeatedly 
calls advance(), then sends the emitted layout to the graph panel.</p>

<p>The graph panel, in turn, is the usual Swing object; it iterates in a 
paintComponent loop. There is a subtlety here, too, but to clarify it, I
must first discuss the Pipeline.</p>

<hr>

<p>The Pipeline is the mechansim that applies any necessary distortions, twists,
resizings to the graph. It consists of zero or more LayoutTransformers. 
A LayoutTransformer modifies (in place) an EmittedLayout to match the needs
of this particular display.</p>

<p>The default pipeline is pre-loaded (in the LocalGraphDraw c'tor)
with a FitOnScreen transformer, which expands the current visualization 
to take up the full screen, and the SlightMarginTransformer, which 
adds a small amount of space on all sides. (How can these be removed? 
Not easily, right now.)</p>

<p>So when a new layout is created by the LayoutIterator and the IterableLayout, 
it must be shuffled through the pipeline (in the GraphLayoutPanel). 
First, a copy of the layout is kept. (You'll see why in a moment). 
Second, it is  processed through the pipeline foreward: first the 
FitOnScreen, then the SlightMargin, and then any others that the 
user has added.</p>

<p>What happens when the screen is resized? Two things. 
First, the pipeline may need to be adjusted. (Both FitOnScreen and SlightMargin,
for instance, care about the dimensions of the screen). As such, a Dimension object
is passed BACKWARDS through the pipeline. That is, the last object is sent that
object, then the second-to-last, and so on. This allows different stages of the 
pipeline to constrain the area in which a previous layout could work. (This is 
Pipeline.adjustSizes().) </p>

<p>Second, the copy of the layout that we made two paragraphs back is shuffled 
through the pipeline. This is GraphLayoutPanel.resizeLayouts(). Good thing 
we had a clean copy, since every pass through the pipeline can stomp on the
previous one.</p>

<hr>

<p>Last, the new, final EmittedLayout is used for two tasks. 
First, it gives the locations of the vertices and edges to the renderer. (
The vertices and edges are currently drawn in a random order, although all
edges will be drawn before any vertices are. Perhaps this might be fixed?)
Second, it answers the function "getClosestVertex" and "getClosestEdge"
mouse clicks, and thus figures out which mouse click goes with which vertex.</p> 

<p>The vertexes and edges, incidently, are drawn by a VertexRenderer and an
EdgeRenderer. The user is responsible for providing both.</p>

<hr>

<p>So why is this system so general?</p>

<p>Well, because it allows a lot of very cool stuff. For example, it's
possible (and easy!) to generate graphs connected by non-straight lines.
Add in a CrookedLineTransformer somewhere in the pipeline, and you are
pretty much set. (You'll also need a good renderer).</p>

<p>Want to map things in a hyperbolic space? Should be little difficulty.</p>

<p>Want to paint nodes green? Very easy!</p>

<hr>

<p>What the system does NOT provide is: 
<ol>
<li/>Vertex dragging. In particular, because of the current setup, it is
hard to figure out what the reverse mapping of a dragged vertex is. (Just
because it was dragged +3y in the final, visual system doesn't mean that it
was dragged +3y in the original coordinate system). One possible answer is to
assume that the coordinate systems are at least relatively equal, and to
simply send the changed coordinates back to the original layout.

<li/>No universal mechanism for picked or selected vertices. (Ought tehre to be?)

<li/>No mechanism for freezing vertices in place. (This may need to be
supported at the IterativeLayout level.)

<li/>Graph mutation. (Still working on this one.)

<li/>We also had a user request for locking vertices in place after they are first 
laid out--but allowing the graph to mutate. (Still also working on this one).
</ol>
</p>

<hr>
 
Notes on graph mutation: STEPS ARE
<ol>
<li/>Graph mutation is triggered by an [what].update( g ) command
	[what] then:
<li/> Calculates which vertices are new, and which vertices are old
<li/> Asks the current UpdatableIterable layout to take care of it. The UIL
will:
    <ol>
	<li/> Initialize VV's for those new vertices and new edges
	<li/> Remove the VE's for the old vertices and the old edges
	</ol>
</ol>	
<p>Both will happen "in their own sweet time"--that is, it's the visualizations'
responsibility to decide what happens with them.</p>
<P>

<P>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../samples/graph/southern/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../samples/preview_new_graphdraw/event/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
